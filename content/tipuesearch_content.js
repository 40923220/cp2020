var tipuesearch = {"pages": [{'title': 'about', 'text': '40923220 \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n', 'tags': '', 'url': 'about.html'}, {'title': '成功的PC硬件', 'text': '\n PC Hardware是一門在線課程，其中的內容將以文本和活動的形式呈現。 \n 與傳統課程相比，您將擁有更多的靈活性，但是您也將對自己的學習承擔更多責任。 您將需要： \n \n 計劃如何遍歷每個單元。 \n 確定如何使用課程的各種功能來幫助您學習。 \n 確定何時需要尋求其他支持。\xa0     \n', 'tags': '', 'url': '成功的PC硬件.html'}, {'title': 'HW1', 'text': '', 'tags': '', 'url': 'HW1.html'}, {'title': 'unit3Hardware Components', 'text': 'Unit3: Hardware Components( 硬件組件 ) \n PCH 6 \xa0 / RAM Basics( RAM基礎) \n In order for a computer to function, it needs a temporary storage space to store data that is input into the computer from the user or the hard drive, and to store data that is about to be written to more permanent storage. This temporary storage is called RAM, or random access memory. RAM is the workspace for the CPU to process data. When the computer boots up the OS (operating system) loads the start files into RAM. RAM is dynamic and constantly changing. It operates much faster than a hard drive, and can be changed at any time by the computer. RAM is volatile memory which means it loses all its information when power is removed, so it can only be used as temporary storage. This memory is used for operating systems startup files (bootstrap loader), programs, data, and disk caching. Adding RAM to a computer is one of the easiest and most effective upgrades a person can perform, since it drastically improves the transfers between the CPU and the other input devices (like hard drives), and this increases the overall speed of the computer. \n 翻譯: \n 為了使計算機正常運行，它需要一個臨時存儲空間來存儲從用戶或硬盤驅動器輸入到計算機中的數據 ，並將要寫入的數據存儲到更永久的存儲器中。該臨時存儲稱為RAM或隨機存取存儲器。  RAM是CPU處理數據的工作區。計算機啟動時，操作系統（操作系統）將啟動文件加載到RAM中。  RAM是動態的並且不斷變化。它的運行速度比硬盤驅動器快得多，並且可由計算機隨時更改。  RAM是易失性內存，這意味著在斷電時它會丟失所有信息，因此只能用作臨時存儲。 該內存用於操作系統啟動文件（引導加載程序），程序，數據和磁盤緩存。 向計算機添加RAM是一個人可以執行的最簡單，最有效的升級之一， 因為它可以極大地改善CPU與其他輸入設備（如硬盤驅動器）之間的傳輸 ，從而提高了計算機的整體速度。', 'tags': '', 'url': 'unit3Hardware Components.html'}, {'title': 'PCH 6內存模塊（內存模塊）', 'text': '內存的用途之一是充當磁盤緩存。 就像我們在處理器中提到的緩存一樣，RAM充當了硬盤驅動器中最近使用和常用數據的更快的臨時存儲區域。 由於訪問RAM比查找硬盤驅動器扇區中的數據更快，因此RAM可提高計算機的性能。 僅當內存中有可用空間時才可以使用磁盤緩存。 但是，如果您沒有足夠的物理內存可用怎麼辦？ 當物理內存不足時，計算機將創建虛擬內存。 虛擬內存有時也稱為“頁面文件”或“交換文件”。 虛擬內存是RAM的慢速替代品，因為它是在硬盤驅動器上創建的臨時文件，並模擬物理RAM。 本質上， 磁盤緩存使RAM可以充當極快的硬盤驅動器，而虛擬內存由硬盤驅動器上的文件組成，它們的運行速度非常慢。 RAM比磁性存儲（如硬盤驅動器和軟盤）或光學存儲（DVD，CD，藍光）快。 這是因為RAM是固態設備，訪問時間沒有特別長。 RAM的運行速度為十億分之一秒（十億分之一秒），而硬盤驅動器和其他磁性介質的運行速度非常慢，其運行速度為千分之一秒（毫秒）。 RAM不足會導致計算機運行更慢。 因此，升級RAM是A +技術人員執行的最常見的升級之一。 RAM比磁性存儲（如硬盤驅動器和軟盤）或光學存儲（DVD，CD，藍光）快。 這是因為RAM是固態設備，訪問時間沒有特別長。 RAM的運行速度為十億分之一秒（十億分之一秒），而硬盤驅動器和其他磁性介質的運行速度非常慢，其運行速度為千分之一秒（毫秒）。 RAM不足會導致計算機運行更慢。 因此，升級RAM是A +技術人員執行的最常見的升級之一。 RAM比磁性存儲（如硬盤驅動器和軟盤）或光學存儲（DVD，CD，藍光）快。 這是因為RAM是固態設備，訪問時間沒有特別長。 RAM的運行速度為十億分之一秒（十億分之一秒），而硬盤驅動器和其他磁性介質的運行速度非常慢，其運行速度為千分之一秒（毫秒）。 RAM不足會導致計算機運行更慢。 因此，升級RAM是A +技術人員執行的最常見的升級之一。 RAM不足會導致計算機運行更慢。 因此，升級RAM是A +技術人員執行的最常見的升級之一。 RAM不足會導致計算機運行更慢。 因此，升級RAM是A +技術人員執行的最常見的升級之一。 \n 翻譯： \n 就像我們在處理器中提到的緩存一樣， RAM放入了硬盤驅動器中最近使用和常用數據的恢復的臨時存儲區域。通過訪問RAM比查找硬盤驅動器風扇區，數據存儲區， 因此RAM可提高計算機的性能。僅當內存中有可用空間時才可以使用磁盤緩存。 但是，如果您沒有足夠的物理內存可用怎麼辦？當物理內存不足時，計算機將創建虛擬內存。 虛擬內存有時也稱為“頁面文件”或“交換文件”  。虛擬內存是RAM的慢速替代品，因為它是在硬盤驅動器上創建的臨時文件，並模擬物理RAM。 本質上，，磁盤緩存使RAM可以對準極快的硬盤驅動器，而虛擬內存由硬盤驅動器上的文件組成，它們的運行速度非常慢 。RAM比磁性存儲（如驅動器和軟盤）或光學存儲（DVD，CD，藍光）快。 這是因為RAM是固態設備，訪問時間沒有特別長 。RAM的運行速度為十億分之一秒（十億分之一秒），而硬盤驅動器和其他磁性介質的運行速度非常慢 因此，升級RAM是A +技術人員執行的最常見的升級之一。 ，， 其運行速度為千分之一秒（毫秒） 。 \n 分類記憶（分類記憶） \n RAM有多種分類：內存模塊類型，芯片類型，速度和奇偶校驗。 內存模塊因類型而異，具體取決於母板和母板的外形尺寸。 內存模塊由其上的針腳數量定義，例如240針DIMM（雙列直插式內存模塊），184針DIMM等。 \n RAM也根據存儲芯片類型進行分類。 過去，系統根據製造商使用不同類型的芯片，但是當前的系統大多使用相同類型的芯片，通常是DDR（雙數據速率），DDR2或DDR3。 儘管DDR是最常見的類型，但某些獨特的系統可能會使用RDRAM（Rambus動態隨機存取存儲器）。 \n 另一個RAM分類基於速度。 較舊的內存以納秒（例如60納秒）分類。 隨著時間的流逝，所有內存的速度幾乎相同，以納秒為單位，因此他們將其更改為總線速度（例如，PC-133內存以133 MHz的總線速度運行）。 現在，大多數當代內存都是按吞吐量衡量的（PC2-6400，工作於800 MHz，但具有6.4 GBps的帶寬）。 \n 最後，可以使用奇偶校驗，非奇偶校驗或ECC購買存儲器並按其分類。 奇偶校驗存儲器在將數據讀/寫到芯片時檢查錯誤。 儘管奇偶校驗內存可以檢測到錯誤，但無法糾正錯誤。 非奇偶校驗內存是台式計算機中最常見的類型之一，沒有錯誤檢查功能。 糾錯碼（ECC）是奇偶校驗的高級版本，可以發現錯誤並在從芯片讀取/寫入該錯誤時糾正該錯誤。 由於這些附加功能，ECC往往比等效的非奇偶校驗RAM慢。 \n RAM有多種分類：內存模塊類型，芯片類型，速度和奇偶校驗。內存模塊因類型而異， 具體取決於母板和母板的外形尺寸。 內存模塊由其上的針腳數量定義，例如240針DIMM（雙列直插式內存模塊），184針DIMM等。 \n \nRAM也根據存儲芯片類型進行分類。過去，系統根據製造商使用不同類型的芯片 ， 但是當前的系統大多使用相同類型的芯片 ，通常是DDR（雙數據速率），DDR2或DDR3。 儘管DDR是最常見的類型，但某些獨特的系統可能會使用RDRAM（Rambus動態隨機存取存儲器）。 \n \n另一個RAM分類基於速度。以前的內存以納秒（例如60納秒）分類。通過時間的流逝，所有內存的速度幾乎相同， 以納秒為單位，因此他們將其更改為總線速度（例如，PC-133內存以133 MHz的總線速度運行）。 現在，大多數當代內存都是按菱形的（PC2-6400，工作於800 MHz，但具有6.4 GBps的帶寬）。 \n \n最後，可以使用奇偶校驗，非奇偶校驗或ECC購買內存並按其分類。奇偶校驗存儲器在將數據讀/寫到芯片時檢查錯誤。 儘管奇偶校驗內存可以檢測到錯誤，但無法糾正錯誤。非奇偶校驗校準內存是台式計算機中最常見的類型之一， 沒有錯誤檢查功能。糾錯碼（ECC）是奇偶校驗的高級版本，可以發現錯誤並在從芯片讀取/寫入該錯誤時糾正該錯誤。 由於這些附加功能，ECC通常比等效的非奇偶校驗RAM \n \xa0 \n', 'tags': '', 'url': 'PCH 6內存模塊（內存模塊）.html'}, {'title': 'PCH 6 History of RAM的歷史記錄', 'text': 'Different types of RAM have been in common use during different time periods. It is important to understand them all, because many companies use a mix of legacy systems and more current ones. DRAM, or dynamic RAM, is one of the oldest types. It requires frequent refreshing of contents. DRAM stores each bit of data or program code in a storage cell consisting of a capacitor and a transistor, and is typically organized in a rectangular configuration of storage cells. A DRAM storage cell is dynamic in that it needs to be refreshed or given a new electronic charge every few milliseconds to compensate for charge leaks from the capacitor. \n SRAM, or static RAM, solved the issue of the need for constant refreshing, but it is quite expensive to manufacture. Therefore, SRAM is only used for very high-speed needs, such as level 1, level 2, and level 3 CPU caches, hard drive buffers, and LCD screen buffers. \n SDRAM, or synchronous DRAM, was the first memory that operated at the same speed as the motherboard’s bus. The initial chips were 168-pin dual in-line memory modules, which have their speed rated in MHz. Common naming conventions include PC-66 (which is equivalent to 66 Mhz), or PC-133, or PC-266. \n While SDRAM performs at the same speed as the motherboard’s bus, the CPU operates many times faster than the motherboard’s bus. DDR SDRAM stands for double data rate synchronous dynamic random access memory. This type of memory can transfer data two times per clock cycle, thereby doubling the speed over traditional SDRAM. These chips come in 184-pin varieties, rated in MBps (throughput). A good example of this is something like PC-1600, which is 1600 MBps throughput. \n DDR2 SDRAM is double double data rate SDRAM, which has a higher \xa0 latency \xa0 but faster access to the external bus. These chips have 240 pins to connect their modules to the slot, and are also rated in MBps, such as PC2-4200, which is 4200 MBps (or 4.2 GBps). \n DDR3 SDRAM is known as double data rate 3 SDRAM, and is the latest generation of SDRAM in use today. It runs at a lower voltage and is faster than DDR2, but again the latency is increased over the previous DDR2 modules. These modules also have 240 pins, but they are “keyed” differently than DDR2. The “keyed” portion is where the gap in the pins is located, so only a DDR2 will fit in a DDR2 slot, and a DDR3 will fit only in a DDR3 slot. The common notation for these is PC3-10600, where the 10600 is the speed in MBps. \n Rambus direct ram (RDRAM) is also known as RIMM (Rambus in-line memory module). These modules come in a 184-pin variant (16-bit version) and a 232-pin variant (32-bit version). Each empty slot in the motherboard has to have a continuity module (CRIMM) placed inside it, or the motherboard won’t recognize the memory properly. This is not used in recent systems, but was used heavily in Pentium 4 systems. The RDRAM is measured in MBps, such as RIMM 4200 (or 4200 MBps). \n 翻譯: \n 在不同時間段內，通常使用不同類型的RAM。了解所有這些信息非常重要，因為許多公司使用的都是舊系統和最新系統。 DRAM或動態RAM是最古老的類型之一。它需要經常刷新內容。 DRAM將數據或程序代碼的每一位存儲在由電容器和晶體管組成的存儲單元中，並且通常以矩形配置的存儲單元來組織。 DRAM存儲單元是動態的，因為它需要每幾毫秒刷新一次或給其提供新的電荷，以補償電容器的電荷洩漏。\n\nSRAM或靜態RAM解決了不斷刷新的問題，但製造成本很高。因此，SRAM僅用於非常高速的需求，例如1級，2級和3級CPU高速緩存，硬盤驅動器緩衝區和LCD屏幕緩衝區。\n\nSDRAM或同步DRAM是第一個以與主板總線相同的速度運行的內存。最初的芯片是168針雙列直插式內存模塊，其速度額定為MHz。常見的命名約定包括PC-66（相當於66 Mhz），PC-133或PC-266。\n\n儘管SDRAM的性能與主板總線相同，但CPU的運行速度比主板總線快許多倍。 DDR SDRAM代表雙倍數據速率同步動態隨機存取存儲器。這種類型的存儲器可以在每個時鐘週期兩次傳輸數據，從而使速度比傳統SDRAM快一倍。這些芯片有184引腳的型號，額定為MBps（吞吐量）。一個很好的例子就是PC-1600，吞吐量為1600 MBps。\n\nDDR2 SDRAM是雙倍數據速率SDRAM，具有更高的延遲，但對外部總線的訪問速度更快。這些芯片具有240個引腳以將其模塊連接到插槽，並且還以MBps額定，例如PC2-4200，即4200 MBps（或4.2 GBps）。 \n DDR3 SDRAM被稱為雙倍數據速率3 SDRAM，是當今使用的最新一代SDRAM。它在較低的電壓下運行，並且比DDR2更快，但是與之前的DDR2模塊相比，延遲又增加了。這些模塊還具有240針，但是它們的“鍵控”與DDR2不同。 “鍵控”部分是引腳之間的間隙所在的位置，因此只有DDR2可以插入DDR2插槽，而DDR3只能插入DDR3插槽。這些的常用符號是PC3-10600，其中10600是MBps的速度。\n\nRambus直接RAM（RDRAM）也被稱為RIMM（Rambus嵌入式存儲模塊）。這些模塊具有184針變體（16位版本）和232針變體（32位版本）。主板上的每個空插槽都必須在其中放置一個連續性模塊（CRIMM），否則主板將無法正確識別內存。在最近的系統中未使用此功能，但在Pentium 4系統中大量使用了此功能。 RDRAM以MBps為單位進行度量，例如RIMM 4200（或4200 MBps）。 \n There are other variants of memory that have been used over the years, but they are not common today. The single inline memory module, or SIMM, has either 30 or 72 connectors on both sides of the chip. The single inline pin package, or SIPP, has only 30 pins, and they are physical pins instead of connectors. \n Dual inline memory module, or DIMM, is what is used for DDR, DDR2, and DDR3 chips, with each side of the module having different pinouts in the connectors. The SODIMM, small outline DIMM, is a compact version of memory used in laptops, notebooks, and printers. It can come in DDR SODIMM, DDR2 SODIMM, or DDR3 SODIMM. SODIMM is very common and still heavily used today. \n Finally, there is a laptop version of Rambus memory called small outline Rambus module, but it is rarely used in contemporary systems. \n 翻譯: \n 多年以來，內存還使用了其他變體，但如今並不常見。單列直插式內存模塊或SIMM在芯片的兩側都有30或72個連接器。單列直插式引腳封裝或SIPP只有30個引腳，它們是物理引腳而不是連接器。 DDR，DDR2和DDR3芯片使用雙列直插式內存模塊或DIMM，模塊的每一側在連接器中具有不同的引腳排列。 SODIMM是小型DIMM，是便攜式計算機，筆記本計算機和打印機中使用的緊湊型內存。它可以採用DDR SODIMM，DDR2 SODIMM或DDR3 SODIMM。 SODIMM非常普遍，今天仍然大量使用。 最後，有一種筆記本電腦版本的Rambus內存，稱為小型Rambus模塊，但在現代系統中很少使用。 \n', 'tags': '', 'url': 'PCH 6 History of RAM的歷史記錄.html'}, {'title': 'PCH 6 Parity(奇偶校驗)', 'text': 'Memory Module Width \n Memory module width is measured by the number of bits that can be transferred. Memory began in 8-bit varieties, but has increased to 16 bits, 32 bits, and now 64 bits in current systems. Memory must be added in banks to ensure the width equals the width of the memory bus. For example, if you need 64 bits and a single module offers 64 bits, then it will have one module in the bank. Dual-channel memory requires double the amount, therefore two 64-bit (128 bit) DIMMs are needed in the banks, while three are required for triple-channel, as was mentioned earlier. \n \n Parity and ECC \n Parity is used to perform basic error checking and to ensure the memory contents are reliable. This memory is slower than non-parity, but adds the reliability needed for servers and certain desktop workstations. \n Parity checking is a rather simple method of detecting memory errors, without any correction capabilities. Parity is signified in a single bit of data that is added to the transmitted data string. If the module normally would have seven bits of data, an eighth is added as the parity bit. If the module normally would have eight chips for data, a ninth chip is added for parity. \n Every byte has a parity bit associated with it. In the case that seven bits make up the original data, there are eight total bits transmitted (seven original data bits plus one parity bit). In the case that eight bits make up the original data, a total of nine bits are transmitted (eight data bits plus one parity bit). The parity bit is set at write time, and then calculated and compared at read time to determine if any of the bits have changed since the data was stored. This type of checking is limited to detection of single bit errors. If two bits have been altered, the parity check will “pass,” and the error is allowed to possibly corrupt the data. \n Parity checking can be implemented either as “0” parity or “1” parity. When the byte is stored, the number of zeros (or ones, if “1” parity is selected) is added up. The result is stored in the parity bit – “1” if odd, “0” if even. When that byte is read from memory, the bits are again counted and the result is compared against what was stored in the parity bit. A match means that the data was not changed from when it was stored (or that two bits were altered in such a way that the result is the same). \n The process to determine the parity bit is the same, regardless of the number of original data bits transmitted. Typically, there are either seven or eight bits of original data. \n The parity bit is determined by counting the number of “1” bits in a data string. \n \n \xa0翻譯: 內存模塊寬度 內存模塊的寬度由可傳輸的位數決定。內存最初以8位形式出現， 但在當前系統中已增加到16位，32位和現在的64位。必須以存儲體的形式添加內存， 以確保其寬度等於內存總線的寬度。例如，如果您需要64位，而單個模塊提供64位， 則庫中將只有一個模塊。如前所述，雙通道內存需要兩倍的存儲量， 因此存儲庫中需要兩個64位（128位）DIMM，而三通道則需要三個。 \n 奇偶校驗和ECC \n 奇偶校驗用於執行基本的錯誤檢查並確保內存內容可靠。 此內存比非奇偶校驗慢，但增加了服務器和某些台式機工作站所需的可靠性。 \n 奇偶校驗是一種檢測內存錯誤的相當簡單的方法，沒有任何校正功能。 奇偶校驗在添加到傳輸數據字符串的單個數據位中表示。 如果模塊通常具有七個數據位，則將八分之一添加為奇偶校驗位。 如果模塊通常有八個芯片用於數據，則添加第九個芯片以實現奇偶校驗。 \n 每個字節都有一個與之關聯的奇偶校驗位。 在七位組成原始數據的情況下，總共傳輸了八位（七位原始數據位加一個奇偶校驗位）。 在八位組成原始數據的情況下，總共傳輸九位（八位數據位加一位奇偶校驗位）。 奇偶校驗位在寫入時設置，然後在讀取時進行計算和比較，以確定自存儲數據以來是否有任何位發生了更改。 這種類型的檢查僅限於檢測單個位錯誤。 如果更改了兩位，則奇偶校驗將“通過”，並且允許該錯誤可能破壞數據。 \n 奇偶校驗可以實現為“ 0”奇偶校驗或“ 1”奇偶校驗。 存儲字節時，將加零（如果選擇了“ 1”奇偶校驗，則為零）的數目。 結果存儲在奇偶校驗位中-如果為奇數，則為“ 1”；如果為偶數，則為“ 0”。 當從內存中讀取該字節時，將再次對這些位進行計數，並將結果與奇偶校驗位中存儲的結果進行比較。 匹配表示數據從存儲時起就沒有改變（或以結果相同的方式更改了兩位）。 \n 不管發送的原始數據位數如何，確定奇偶校驗位的過程都是相同的。 通常，數據有七位或八位。 \n 奇偶校驗位是通過對數據字符串中“ 1”位的數量進行計數來確定的。 \n', 'tags': '', 'url': 'PCH 6 Parity(奇偶校驗).html'}, {'title': 'PCH 6 Installing MemoryModules(安裝內存模塊)', 'text': "Installing memory is a common computer upgrade and a very easy task to perform. Memory modules are installed as “sticks” (or modules) of memory into the “slots” on the motherboard. \n \n \n The process of installing memory sticks is fairly easy, but caution and precision are necessary. To install memory sticks (or modules): \n \n Always ensure you take proper ESD (electrostatic discharge) protection measures to ensure both the motherboard and memory modules are not harmed during installation. \n Turn off the computer and unplug the power cord. \n Open the case and begin the installation of the memory sticks. Always hold the memory sticks by the sides of the chips and never by the gold contacts. \n Line up the memory module’s connector with the slot on the motherboard. \n Verify that the locking tabs are in the open position. \n Push the module straight down until the tabs swivel to the locking position (this takes force). \n \n Important note: Never touch the gold connectors on the modules! Corrosion of the contacts can occur, or the module may be damaged due to electrostatic discharge. \n To explore more about how to install RAM, visit \xa0 www.wikihow.com/Install-RAM . \n 安裝內存是計算機的常見升級，並且是很容易執行的任務。 內存模塊作為內存的“棒”（或模塊）安裝在主板上的“插槽”中。 \n 安裝記憶棒的過程相當容易，但是必須謹慎且精確。要安裝記憶棒（或模塊）： \n \n 始終確保採取適當的ESD（靜電釋放）保護措施，以確保在安裝過程中不會損壞主板和內存模塊。 \n 關閉計算機電源，然後拔下電源線。 \n 打開外殼，開始安裝記憶棒。 始終將記憶棒放在芯片的側面，而不要緊握金觸點。 \n 將內存模塊的連接器與主板上的插槽對齊。 \n 確認鎖定卡舌處於打開位置。 \n 垂直向下推動模塊，直到卡舌旋轉到鎖定位置（需要用力）。 \n \n 重要說明：切勿觸摸模塊上的金色連接器！ 觸點可能會腐蝕，或者由於靜電放電會損壞模塊。 \n 要了解有關如何安裝RAM的更多信息，請訪問 www.wikihow.com/Install-RAM 。 \n \n PCH 6 Introduction to BIOS CMOSand Firmware( BIOS CMOS和固件簡介 ) \n When a computer is turned on, the computer’s microprocessor uses a program called the\xa0 BIOS \xa0 (basic input/output system) to start the computer system. The BIOS also manages data flow between the computer's operating system and attached/connected devices, such as the hard drive, video adapter, keyboard, mouse, and printer. \n \n A computer’s BIOS is the most common example of \xa0 firmware . Firmware is software on a chip, and is the first software run by the computer when the machine is booted up. The BIOS has several roles, including performing the power-on self-test, which tests and initializes the processor, video card, disk drives, and adapters. The BIOS also includes the low-level “operating system” for the computer, which allows the computer to take input from and give output to the most basic components, including the keyboard, mouse, and disk drives. The BIOS is stored in a ROM (Read-only memory) chip, but can be upgraded through a process call “flashing.” \n While the BIOS is a program that allows the user to make changes to the settings, the settings themselves are stored in the complementary metal-oxide semiconductor, or \xa0 CMOS . The CMOS is a battery-powered memory chip. \n Understanding BIOS and CMOS \n \n \n The BIOS is used to configure common settings, such as the order in which devices are read by the computer. This order is known as the boot order. In addition, the BIOS is also used in the configuration of settings that turn on and off various input/output ports, and the configuration of various CPU settings such as virtualization \xa0 and \xa0 overclocking \xa0 . \n Be very careful when making changes to the BIOS. Incorrect settings may keep your computer from booting. \n \n \n BIOS configures the following settings: \n \n Boot order \n Storage devices (USB drives, hard drives, floppy drives, optical drives) \n Built-in ports (SATA, eSATA, PATA, USB, IEEE-1394, serial, parallel, PS/2) \n AGP, PCI, PCIe slots \n Integrated chipsets (audio, video, network) \n Virtualization \n Clock speed \n Memory (RAM) \n Power management \n Intrusion detection \n Passwords and encryption \n PC health tools (temperature, voltage, etc.) \n Direct access to the web or other services without booting computer (UEFI specific) \n \n When the power button is pressed on the computer, the first step in the boot process is the power-on self-test, called the \xa0 POST . Once a successful POST occurs, the BIOS reads the settings from the CMOS, and the BIOS looks for an operating system from the configured boot devices. Once it finds the operating system, the operating system’s boot loader begins the operating system boot process, and turns over control of the computer to the operating system. \n \n The boot process: \n \n Power on computer. \n BIOS performs power-on self-test (POST). \n BIOS reads settings from CMOS. \n BIOS looks for operating system from configured boot device. \n \n \n \n \xa0翻譯: \n 開啟計算機後，計算機的微處理器會使用稱為BIOS（基本輸入/輸出系統）的程序來啟動計算機系統。 BIOS還管理計算機操作系統和已連接/已連接的設備（例如硬盤驅動器，視頻適配器，鍵盤，鼠標和打印機）之間的數據流。 \n 計算機的BIOS是最常見的固件示例。固件是芯片上的軟件，是計算機啟動時計算機運行的第一個軟件。 BIOS具有多個角色，包括執行開機自檢，以測試和初始化處理器，視頻卡，磁盤驅動器和適配器。 BIOS還包括用於計算機的低級“操作系統”，它使計算機可以從最基本的組件（包括鍵盤，鼠標和磁盤驅動器）獲取輸入並提供輸出。 BIOS存儲在ROM（只讀存儲器）芯片中，但可以通過過程調用“刷新”進行升級。\n\nBIOS是允許用戶更改設置的程序，而設置本身則存儲在互補金屬氧化物半導體或CMOS中。 CMOS是電池供電的存儲芯片。\n\n了解BIOS和CMOS\nBIOS用於配置通用設置，例如計算機讀取設備的順序。此命令稱為引導命令。此外，BIOS還用於配置打開和關閉各種輸入/輸出端口的設置，以及各種CPU設置（例如虛擬化和超頻）的配置。\n\n更改BIOS時要非常小心。設置不正確可能會導致計算機無法啟動。 \n BIOS配置以下設置：\n\n引導順序\n存儲設備（USB驅動器，硬盤驅動器，軟盤驅動器，光盤驅動器）\n內置端口（SATA，eSATA，PATA，USB，IEEE-1394，串行，並行，PS / 2）\nAGP，PCI，PCIe插槽\n集成芯片組（音頻，視頻，網絡）\n虛擬化\n時鐘速度\n記憶體（RAM）\n能源管理\n入侵檢測\n密碼和加密\nPC健康工具（溫度，電壓等）\n直接訪問Web或其他服務，而無需啟動計算機（特定於UEFI）\n當按下計算機上的電源按鈕時，引導過程的第一步是開機自檢，稱為POST。成功進行POST後，BIOS將從CMOS中讀取設置，然後BIOS從已配置的引導設備中尋找操作系統。找到操作系統後，操作系統的引導加載程序將開始進行操作系統引導過程，並將計算機的控制權移交給操作系統。 \n 引導過程： 打開計算機電源。 BIOS執行開機自檢（POST）。 BIOS從CMOS讀取設置。 BIOS從配置的引導設備中查找操作系統。 \n", 'tags': '', 'url': 'PCH 6 Installing MemoryModules(安裝內存模塊).html'}, {'title': 'PCH 6 CMOS', 'text': "The CMOS (complementary metal-oxide semiconductor) is a battery-powered memory chip. It is nonvolatile memory that stores the BIOS settings and is built into the motherboard. As long as battery power remains, DC (direct current) is provided to the CMOS and allows the settings to be retained. If the computer is constantly losing the settings, the battery will need to be replaced. Older CMOS battery models used the DS12887A battery or AA-sized 3.6 volt Eternacell battery, and normally lasted approximately three years. Newer CMOS models include an internal lithium-ion battery that can last for up to 10 years. The most typical current external battery used is the CR2032, which resembles a standard watch battery. When the battery begins to fail, the first sign to the user is that the system clock frequently loses time. \n \n \xa0CMOS（互補金屬氧化物半導體）是電池供電的存儲芯片。它是非易失性存儲器，用於存儲BIOS設置， 並內置在主板中。只要電池電量剩餘，就會向CMOS提供DC（直流電）並保留設置。 如果計算機不斷丟失設置，則需要更換電池。 較舊的CMOS電池型號使用DS12887A電池或AA尺寸的3.6伏Eternacell電池，通常可以使用大約三年。 較新的CMOS型號包括內置鋰離子電池，該電池可使用長達10年。 當前使用的最典型的外部電池是CR2032，它類似於標準的手錶電池。 當電池開始出現故障時，向用戶顯示的第一個信號是系統時鐘經常浪費時間。  CMOS內存和電池的照片。 \n \n \n PCH 6 Configuring the System BIOS(配置系統BIOS) \n To change the settings in the CMOS, the user needs to enter the BIOS. To do this, the user must press a valid key or key combination during the boot process as set by the computer manufacturer. The most common keys used to enter the BIOS are F2 and/or Delete. Typically, the keystroke required to enter the BIOS is displayed on the monitor during the boot process. If the keystroke isn’t displayed, a quick search of the manufacturer’s website will often tell the user the required keystroke to enter the BIOS. \n A boot screen, which displays the required keystroke to enter the BIOS. Photo used under CC-BY-SA license from \xa0 Chip Poutine . \n The BIOS interface and the keystrokes to enter the BIOS change depending on the BIOS manufacturer. Below are images of the BIOS interface from two different manufacturers. Notice that while the information available is consistent between the two, the interface is slightly different. \n Phoenix Award BIOS Dell BIOS \n \n \n \n \n \n \n Traditionally, there was only a single type of BIOS, which relied fully on text-based menus and the keyboard for input. More recently, most BIOS manufacturers have switched to the unified extensible firmware interface, or \xa0 UEFI . This updated BIOS allows for both keyboard and mouse input, and provides a \xa0 GUI \xa0 instead of the standard text-based menus; support for GUID partition tables ( GPT ) allowing access to disks up to 2 TB and backward compatibility to legacy partition structures (such as the master boot record ( MBR ) and Linux's GRand Unified Bootloader ( GRUB ); boot from removable media; a user interface allowing for online connectivity for web access, diagnostics, and file management; and \xa0 Secure Boot \xa0 which protects pre-operating system code from modification. Some of these UEFI BIOS also include software that allows the user to surf the Internet, play basic games, and use backup programs without ever entering the normal operating system. \n \n EFI's position on the software stack. Licensed under Public Domain via \xa0 Wiki Commons . \n \n \n \n \n Automatic Configuring of BIOS/CMOS \n \n \n \n \n \n Automatic configuration is a feature of some BIOS. While automatic BIOS configuration does not always create the most optimal settings, it can be quite useful if major errors are occurring to create a safe rollback to a known good state. Automatic configuration options include the BIOS defaults (original/failsafe settings) and setup defaults (optimal settings). There is often a turbo setup, which works toward a quick configuration for a faster system. Automatic configuration of the BIOS is often useful while troubleshooting a system. \n Configuration of BIOS settings. Photo used under CC-BY license from \xa0 Linux Screenshots . \n \n \n \n \n 要更改CMOS中的設置，用戶需要進入BIOS。為此，用戶必須在計算機製造商設置的引導過程中按下有效的鍵或組合鍵。用於進入BIOS的最常用鍵是F2和/或Delete。通常，在引導過程中，進入BIOS所需的擊鍵將顯示在監視器上。如果未顯示擊鍵，則快速搜索製造商的網站通常會告訴用戶輸入BIOS所需的擊鍵。 \n BIOS界面和用於進入BIOS的擊鍵取決於BIOS製造商。下面是來自兩個不同製造商的BIOS接口的圖像。請注意，儘管兩者之間的可用信息是一致的，但界面略有不同。 \n 統一可擴展固件接口（UEFI）\n傳統上，只有一種類型的BIOS，它完全依賴於基於文本的菜單和用於輸入的鍵盤。最近，大多數BIOS製造商已切換到統一的可擴展固件接口或UEFI。此更新的BIOS允許鍵盤和鼠標輸入，並提供GUI而不是標準的基於文本的菜單。支持GUID分區表（GPT），允許訪問最大2 TB的磁盤，並向後兼容舊分區結構（例如主啟動記錄（MBR）和Linux的GRand Unified Bootloader（GRUB）；從可移動媒體啟動；用戶界面）允許在線連接以進行Web訪問，診斷和文件管理；以及安全啟動（Secure Boot），可防止操作系統前代碼被修改；其中某些UEFI BIOS還包括允許用戶上網，玩基本遊戲和使用的軟件。無需進入正常操作系統即可備份程序。 \n 自動配置是某些BIOS的功能。儘管自動BIOS配置並非總能創建最佳設置，但是如果發生重大錯誤以將安全回滾創建到已知的良好狀態，它可能會非常有用。自動配置選項包括BIOS默認設置（原始/故障安全設置）和設置默認設置（最佳設置）。通常有一個turbo設置，可以快速配置以實現更快的系統。在對系統進行故障排除時，BIOS的自動配置通常很有用。 \n", 'tags': '', 'url': 'PCH 6 CMOS.html'}, {'title': 'PCH 6 PowerOn SelfTest (POST) and Error Reporting', 'text': 'PCH 6開機自檢（POST）和錯誤報告 \n When power is turned on, the POST (power-on self-test) is the diagnostic testing sequence that a computer\'s basic input/output system (or "starting program") runs to determine if the computer keyboard, random access memory, disk drives, and other hardware are working correctly. The POST is the initial test performed by the BIOS upon booting. The role of the POST is to find errors in hardware, and report those errors. The POST checks the following: \n \n CPU and parts of BIOS \n System time \n Video display card \n Memory \n Keyboard \n Disk drives \n \n If the necessary hardware is detected and found to be operating properly, the computer begins to boot. If the hardware is not detected or is found not to be operating properly, the BIOS issues an error message. This error message may be text on the display screen and/or a series of coded beeps, depending on the nature of the problem. Since the POST runs before the computer\'s video card is activated, it may not be possible to progress to the display screen. The pattern of beeps may be a variable number of short beeps or a mixture of long and short beeps, depending on what type of BIOS is installed. The pattern of beeps contains messages about the nature of the problem detected. For example, if the keyboard is not detected, a particular pattern of beeps will inform you of that fact. An error found in the POST is usually fatal (that is, it causes the current program to stop running) and will halt the boot process, since the hardware checked is absolutely essential for the computer\'s functions. \n The pattern of beeps is like Morse code. The number and sequence of beeps has a meaning set by the computer manufacturer. Therefore, the meaning of each beep differs by manufacturer. A chart that includes some AMI and Dell beep codes is shown below. \n \n \n \n BEEP CODE \n AMI \n DELL \n \n \n \n \n 1 \n DRAM refresh failure \n BIOS ROM corruption or failure \n \n \n 2 \n Parity circuit failure \n RAM not detected \n \n \n 3 \n Base 64K RAM failure \n Motherboard failure \n \n \n 4 \n System timer failure \n RAM failure \n \n \n 5 \n Process failure \n CMOS battery failure \n \n \n \n \n Beep Codes \n \n Here is a sample beep code from a computer having a problem: \n \n \n \n This beep code consists of two short beeps. What does this POST beep sequence mean? It depends on the BIOS’s manufacturer. \n Use a search engine to search for "AMI beep codes." \xa0 This might be a typical result. \xa0 This website tells us that on an AMI computer, two short beeps indicate a memory parity error. \n Now search for "AST Research BIOS beep codes." \xa0 Here is a typical result. \xa0 This website tells us that on an AST Research BIOS computer, two short beeps indicate a keyboard controller buffer failure. \n An Internet search for "IBM bios beep codes" would indicate that this beep code indicates a POST error, and that you should review the screen for the error code. \n Knowing the BIOS manufacturer is important when diagnosing a problem during the POST, as the meaning of the beep codes vary by manufacturer. \n 開機時，POST（開機自檢）是計算機基本輸入/輸出系統（或“啟動程序”）運行以確定計算機鍵盤，隨機存取存儲器，磁盤驅動器的診斷測試順序。 ，並且其他硬件運行正常。 POST是BIOS在引導時執行的初始測試。 POST的作用是查找硬件錯誤，並報告這些錯誤。 POST檢查以下內容： CPU和部分BIOS 系統時間 視頻顯示卡 記憶 鍵盤 磁盤驅動器 如果檢測到必要的硬件並發現其運行正常，則計算機將開始啟動。如果未檢測到硬件或發現硬件運行不正常，BIOS將發出錯誤消息。根據問題的性質，此錯誤消息可能是顯示屏上的文本和/或一系列編碼的嗶聲。由於POST在激活計算機的視頻卡之前運行，因此可能無法進入顯示屏幕。嗶聲的模式可以是可變數目的短嗶聲，也可以是長短嗶聲的混合，具體取決於安裝的BIOS類型。嗶聲的模式包含有關所檢測問題性質的消息。例如，如果未檢測到鍵盤，則特定的嗶嗶聲將告知您該事實。 POST中發現的錯誤通常是致命的（也就是說，它導致當前程序停止運行），並且將終止引導過程，因為檢查的硬件對於計算機的功能絕對必要。 嗶聲的模式類似於莫爾斯電碼。嗶聲的數量和順序由計算機製造商設定。因此，每個嗶嗶聲的含義因製造商而異。包含一些AMI和Dell嗶聲代碼的圖表如下所示。 此蜂鳴聲代碼包含兩個短蜂鳴聲。這個POST嗶嗶聲序列是什麼意思？這取決於BIOS的製造商。 使用搜索引擎搜索“ AMI嗶聲代碼”。這可能是典型的結果。該網站告訴我們，在AMI計算機上，兩聲短促的嗶嗶聲表示內存奇偶校驗錯誤。 現在搜索“ AST Research BIOS嗶聲代碼”。這是一個典型的結果。該網站告訴我們，在AST Research BIOS計算機上，兩聲短促的嗶嗶聲表示鍵盤控制器緩衝區故障。 如果在Internet上搜索“ IBM bios嗶聲代碼”，則表明該嗶聲代碼指示POST錯誤，因此您應該在屏幕上查看錯誤代碼。 在POST期間診斷問題時，了解BIOS製造商很重要，因為嗶嗶代碼的含義因製造商而異。 \n', 'tags': '', 'url': 'PCH 6 PowerOn SelfTest (POST) and Error Reporting.html'}, {'title': 'PCH 6 BIOS Updates(BIOS更新)', 'text': 'So how is the BIOS updated? Recall that BIOS is firmware, or software on a chip. BIOS needs updating when there are power management issues or a processor is upgraded. Always check the manufacturer’s website for the latest firmware version. In the old systems (1980s-1990s), the actual BIOS chip had to be replaced entirely. In newer systems, the BIOS is “flashed.” Flashing is a special process in which the BIOS is overwritten, and shouldn’t be done unless absolutely necessary. Always be sure to back up information before doing a BIOS flash; if a flash doesn’t occur successfully, the system can be irrevocably broken to the point that it will no longer boot. \n \n 那麼如何更新BIOS？記得BIOS是固件或芯片上的軟件。出現電源管理問題或升級處理器時，BIOS需要更新。請始終在製造商的網站上查看最新固件版本。在舊系統（1980年代至1990年代）中，實際的BIOS芯片必須完全更換。在較新的系統中，BIOS被“刷新”。刷新是一個特殊的過程，其中BIOS被覆蓋，除非絕對必要，否則不應該這樣做。始終確保在執行BIOS刷新之前備份信息；如果無法成功進行刷新，則係統將無法恢復，甚至無法啟動。\n\n顯示BIOS設置更新的照片。\n更新BIOS設置。照片由Emmanuel Alanis根據CC-BY許可使用. \n \n', 'tags': '', 'url': 'PCH 6 BIOS Updates(BIOS更新).html'}, {'title': 'HW2', 'text': '', 'tags': '', 'url': 'HW2.html'}, {'title': '變數\xa0Variables', 'text': '參考: https://books.trinket.io/pfe/02-variables.html \xa0 \n 練習 :  https://www.kaggle.com/notebooks?sortBy=dateRun&tab=profile \\ \n A \xa0 value \xa0 is one of the basic things a program works with, like a letter or a number. The values we have seen so far are \xa0 1 , \xa0 2 , and "Hello, World!" \n These values belong to different \xa0 types : \xa0 2 \xa0 is an integer, and "Hello, World!" is a \xa0 string , so called because it contains a "string" of letters. You (and the interpreter) can identify strings because they are enclosed in quotation marks. \n \n The \xa0 print \xa0 statement also works for integers. We use the \xa0 python \xa0 command to start the interpreter. \n 值是程序使用的基本內容之一，例如字母或數字。到目前為止，我們看到的值為1、2和“ Hello，World！”。\n\n這些值屬於不同的類型：2是整數，“ Hello，World！”是字符串，之所以稱為字符串是因為它包含字母的“字符串”。您（和解釋器）可以識別字符串，因為它們用引號引起來。\n\nprint語句也適用於整數。我們使用python命令啟動解釋器。 \n python\n >>>   print ( 4 )\n 4 \n If you are not sure what type a value has, the interpreter can tell you. \n 如果您不確定值的類型，解釋器可以告訴您。 One of the most powerful features of a programming language is the ability to manipulate\xa0 variables . A variable is a name that refers to a value. \n 編程語言最強大的功能之一就是能夠操縱變量。變量是引用值的名稱。 \n Programmers generally choose names for their variables that are meaningful and document what the variable is used for. \n Variable names can be arbitrarily long. They can contain both letters and numbers, but they cannot start with a number. It is legal to use uppercase letters, but it is a good idea to begin variable names with a lowercase letter (you\'ll see why later). \n The underscore character ( _ ) can appear in a name. It is often used in names with multiple words, such as \xa0 my_name \xa0 or \xa0 airspeed_of_unladen_swallow . Variable names can start with an underscore character, but we generally avoid doing this unless we are writing library code for others to use. \n 程序員通常會為其變量選擇有意義的名稱，並記錄該變量的用途。\n\n變量名可以任意長。它們可以包含字母和數字，但不能以數字開頭。使用大寫字母是合法的，但以小寫字母開頭的變量名是一個好主意（稍後您將看到原因）。 \n A \xa0 statement \xa0 is a unit of code that the Python interpreter can execute. We have seen two kinds of statements: print being an expression statement and assignment. \n \n When you type a statement in interactive mode, the interpreter executes it and displays the result, if there is one. \n A script usually contains a sequence of statements. If there is more than one statement, the results appear one at a time as the statements execute. \n 語句是Python解釋器可以執行的代碼單位。我們已經看到了兩種語句：print是表達式語句和賦值。\n\n在交互模式下鍵入語句時，解釋器將執行該語句並顯示結果（如果有）。\n\n腳本通常包含一系列語句。如果有多個語句，則在執行這些語句時，結果一次出現一個。 \n Operators \xa0 are special symbols that represent computations like addition and multiplication. The values the operator is applied to are called \xa0 operands . \n The operators \xa0 + , \xa0 - , \xa0 * , \xa0 / , and \xa0 ** \xa0 perform addition, subtraction, multiplication, division, and exponentiation, \n 運算符是特殊的符號，代表加法和乘法之類的計算。應用該運算符的值稱為操作數。\n\n運算符+，-，*，/和**執行加，減，乘，除和乘冪運算。 \n \xa0 \n \n \n', 'tags': '', 'url': '變數\xa0Variables.html'}, {'title': '條件式Conditional execution', 'text': '參考: https://books.trinket.io/pfe/03-conditional.html \xa0 \n 練習: https://www.kaggle.com/nfu40923220/cp2020conditional-execution \n', 'tags': '', 'url': '條件式Conditional execution.html'}, {'title': 'HW3', 'text': '', 'tags': '', 'url': 'HW3.html'}, {'title': 'Exercise3', 'text': 'List Less Than Tenlist numbers elements if conditional\xa0 \xa0 ( 有條件列出數字元素 ) \n Exercise 3 (and \xa0 Solution ) \n \xa0 \n Take a list, say for example this one: \n a = [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89] and write a program that prints out all the elements of the list that are less than 5. \n 拿一個清單，例如說一個：  a = [1、2、3、5、8、13、21、34、55、89]\n並編寫一個程序，打印出列表中小於5的所有元素。 \n Extras: \n \n Instead of printing the elements one by one, make a new list that has all the elements less than 5 from this list in it and print out this new list. \n Write this in one line of Python. \n Ask the user for a number and return a list that contains only elements from the original list \xa0 a \xa0 that are smaller than that number given by the user. \n \n 附加功能： \n 1.而不是一個一個地打印元素，而是創建一個新列表，其中該列表中的所有元素少於5個，並打印出該新列表。 \n 2. 用一行Python編寫 。 \n 3. 向用戶詢問一個數字，然後返回一個列表，該列表僅包含原始列表a中小於用戶給定數字的元素。 \n Discussion This week’s topics: \n Lists More conditionals (if statements) \n 討論區\n本週主題：\n\n清單\n更多條件（如果語句）   Lists \n This week’s exercise hits on a topic critical for all types and styles of programming: \xa0 lists . Lists are basically an ordered way of grouping things (called \xa0 elements ) - the cool thing about lists in Python is that you can have a list that contains objects of multiple types. Your list can mix between strings, integers, objects, other lists, what have you. \n 清單\n本週的練習涉及一個對所有類型和風格的編程都至關重要的主題：列表。列表基本上是一種將事物（稱為元素）進行分組的有序方式-Python中列表的最酷的功能是您可以擁有一個包含多種類型對象的列表。 您的列表可以混合在字符串，整數，對象，其他列表之間，包括您所擁有的。 \n The way to construct an empty list is just to do \n \n x   =   [] \n \n And your variable \xa0 x \xa0 now holds an empty list. To add things to this list, just “append” them to the list. Like so: \n \n x   =   [] \n x . append ( 3 ) \n \n Your list \xa0 x \xa0 now looks like \xa0 [3] . \n In Python, lists are also \xa0 iterables , which means you can loop through them with a \xa0 for loop \xa0 in a convenient way. (If you come from other languages like C++ or Java you are most likely used to using a counter to loop through indices of a list - in Python you can actually loop through the elements.) I will let the code speak for itself: \n \n my_list   =   [ 1 ,   3 ,   "Michele" ,   [ 5 ,   6 ,   7 ]] \n for   element   in   my_list : \n   print ( element ) \n \n Will yield the result: \n \n 1 \n3\n"Michele"\n[5, 6, 7] \n \n There are many other properties of lists, but for the basic exercise all you should need is this for loop property. Future weeks will address other properties of lists. \n 構造一個空列表的方法就是\n\nx = []\n現在，變量x包含一個空列表。要將內容添加到此列表中，只需將它們“添加”到列表中即可。像這樣：\n\nx = []\nx.append（3）\n您的列表x現在看起來像[3]。\n\n在Python中，列表也是可迭代的，這意味著您可以方便地使用for循環遍歷它們。 （如果您來自其他語言，例如C ++或Java，則最有可能習慣於使用計數器循環遍歷列表的索引-在Python中，您實際上可以循環遍曆元素。）我將讓代碼說明自己：\n\nmy_list = [1，3，“米歇爾”，[5，6，7]]\n對於my_list中的元素：\n  打印（元素）\n將產生結果：\n\n1個\n3\n“米歇爾”\n[5，6，7]\n列表還有許多其他屬性，但是對於基本練習而言，您只需要此for循環屬性。未來幾週將處理列表的其他屬性。 \n More Conditionals \n The nice thing about conditionals is that they follow logical operations. They can also be used to test equality. Let’s do a small example. Let’s say I want to make a piece of code that converts from a numerical grade (1-100) to a letter grade (A, B, C, D, F). The code would look like this: \n \n grade   =   input ( "Enter your grade: " ) \n if   grade   >=   90 : \n   print ( "A" ) \n elif   grade   >=   80 : \n   print ( "B" ) \n elif   grade   >=   70 : \n   print ( "C" ) \n elif   grade   >=   65 : \n   print ( "D" ) \n else : \n   print ( "F" ) \n \n What happens if \xa0 grade \xa0 is 50? All the conditions are false, so \xa0 "F" \xa0 gets printed on the screen. But what if \xa0 grade \xa0 is 95? Then all the conditions are true and everything gets printed, right? Nope! What happens is the program goes line by line. The first condition (grade >= 90) is satisfied, so the program enters into the code inside the \xa0 if \xa0 statement, executing \xa0 print("A") . Once code inside a conditional has been executed, the rest of the conditions are skipped and none of the other conditionals are checked. \n \n 更多條件 關於條件的好處是它們遵循邏輯運算。它們也可以用於測試相等性。讓我們舉一個小例子。假設我要編寫一段代碼，將數字等級（1-100）轉換為字母等級（A，B，C，D，F）。代碼如下所示： 成績=輸入（“輸入您的成績：”） 如果成績> = 90： 打印（“ A”） elif等級> = 80： 打印（“ B”） elif等級> = 70： 打印（“ C”） elif等級> = 65： 打印（“ D”） 其他： 打印（“ F”） 如果年級是50，會發生什麼？所有條件都為假，因此“ F”被打印在屏幕上。但是，如果成績是95，該怎麼辦？然後所有條件都成立，一切都打印出來了，對吧？不！程序將逐行執行。滿足第一個條件（等級> = 90），因此程序將在if語句內輸入代碼，並執行print（“ A”）。一旦執行了條件語句中的代碼，將跳過其餘條件，並且不檢查其他條件。 \n', 'tags': '', 'url': 'Exercise3.html'}, {'title': 'Exercise 4', 'text': 'Divisors\xa0 \xa0 (除數) \n Exercise 4 (and Solution) Create a program that asks the user for a number and then prints out a list of all the divisors of that number. (If you don’t know what a divisor is, it is a number that divides evenly into another number. For example, 13 is a divisor of 26 because 26 / 13 has no remainder.) \n 創建一個程序，詢問用戶一個數字，然後打印出該數字的所有除數的列表。  （如果您不知道除數是多少，該數字將被除以另一個數。例如，13是26的除數，因為26/13沒有餘數。） \n \n The topics that you need for this exercise combine lists, conditionals, and user input. There is a new concept of creating lists. \n There is an easy way to programmatically create lists of numbers in Python. \n \xa0 \n 討論區\n本練習需要的主題包括列表，條件和用戶輸入。有一個創建列表的新概念。\n\n有一種簡便的方法可以在Python中以編程方式創建數字列表。 \n To create a list of numbers from 2 to 10, just use the following code: \n \n    x   =   range ( 2 ,   11 ) \n \n Then the variable \xa0 x \xa0 will contain the list \xa0 [2, 3, 4, 5, 6, 7, 8, 9, 10] . Note that the second number in the \xa0 range() \xa0 function is not included in the original list. \n Now that \xa0 x \xa0 is a list of numbers, the same for loop can be used with the list: \n \n    for   elem   in   x :  \n     print   elem \n \n Will yield the result: \n \n   2\n  3\n  4\n  5\n  6\n  7\n  8\n  9\n  10 \n \n 要創建2到10的數字列表，只需使用以下代碼：\n\n  x =範圍（2，11）\n然後，變量x將包含列表[2、3、4、5、6、7、8、9、10]。請注意，range（）函數中的第二個數字未包含在原始列表中。\n\n既然x是一個數字列表，則該列表可以使用相同的for \n \n', 'tags': '', 'url': 'Exercise 4.html'}, {'title': 'Exercise 8', 'text': 'Exercise 8 (and \xa0 Solution ) \n Rock Paper Scissors\xa0 \xa0 \xa0 ( 剪刀石頭布 ) \n Make a two-player Rock-Paper-Scissors game. (Hint: Ask for player plays (using input), compare them, print out a message of congratulations to the winner, and ask if the players want to start a new game) \n Remember the rules: \n \xa0Rock beats scissors \xa0 Scissors beats paper \xa0 \xa0Paper beats rock \n 製作兩人石頭剪刀布遊戲。  （提示：要求玩家玩（使用輸入），進行比較，打印出對獲勝者的祝賀信息，並詢問玩家是否要開始新遊戲）\n\n記住規則：\n\n搖滾剪刀\n剪刀打紙\n紙打石頭 Discussion \n Concepts for this week:\xa0 \xa0 \xa0 \xa0 \xa0 討論區 本週的概念: \n \n While loops\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0While循環 \n Infinite loops\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 無限循環 \n Break statements\xa0 \xa0 \xa0 \xa0 \xa0 中斷聲明 \n \n While loops \n We have already discussed \xa0 for \xa0 loops, or loops that look sequentially (one by one) at elements in a list. There is a second type of loop that works in a slightly different way called a \xa0 while \xa0 loop. \n While循環\n我們已經討論過for循環，或循環（逐個看）列表中元素的循環。還有另一種類型的循環，其工作方式稍有不同，稱為while循環。 \n The idea is simple: while a certain condition is \xa0 True , keep doing something. For example: \n \n    a   =   5 \n   while   ( a   >   0 ): \n     print ( a ) \n     a   -=   1 \n \n The output of this code segment is: \n \n    5 \n   4 \n   3 \n   2 \n   1 \n \n A particularly useful way to use \xa0 while \xa0 loops is checking user input for correctness. For example: \n \n    quit   =   input ( \'Type "enter" to quit:\'   ) \n   while   quit   !=   "enter" : \n     quit   =   input ( \'Type "enter" to quit:\'   ) \n \n The uses for this are infinite, and can (and should!) be combined with conditionals to yield the most efficient results. \n 這個想法很簡單：當某個條件為True時，繼續做某事。例如：\n\n  a = 5\n  而（a> 0）：\n    打印（a）\n    -= 1\n該代碼段的輸出為：\n\n  5\n  4\n  3\n  2\n  1個\n使用while循環的一種特別有用的方法是檢查用戶輸入的正確性。例如：\n\n  quit = input（“輸入“ enter”以退出：\'）\n  而退出！=“輸入”：\n    quit = input（“輸入“ enter”以退出：\'）\n此方法的用途是無限的，並且可以（並且應該！）與條件條件結合使用以產生最有效的結果。 \n Infinite loops \n An infinite loop is a loop that never stops. This means that the condition in the beginning of the while loop will always be true. \n For example: \n \n    i   =   5 \n   while   i   >   0 : \n     print ( "Inside the loop" ) \n \n What will happen is the loop will print out the phrase “Inside the loop” forever and ever. If you are running your computer, you will have to “kill the program” to stop it. Each operating system has a different way of “killing a program” to get out of an infinite loop. \n On Linux: in the terminal, type “CTRL-C” to kill the program that is currently running in the terminal. If you are using the IDLE Python IDE, then you must press “CTRL-D” to exit your running program. When in doubt, do a Google search before you start programming! \n On Windows: type “CTRL-ALT-DEL” and open the task manager to kill the program. \n On Mac: right-click on the task, and kill the program that is running forever. \n If you find yourself in an infinite loop, your program will never end. \n 無限循環\n無限循環是永不停止的循環。這意味著while循環開始時的條件將始終為true。\n\n例如：\n\n  我= 5\n  當我> 0時：\n    print（“循環內”）\n將會發生的是，循環將永遠打印出短語“ Inside the loop”。如果您正在運行計算機，則必須“殺死該程序”以將其停止。每個操作系統都有不同的“殺死程序”以擺脫無限循環的方式。\n\n在Linux上：在終端中，鍵入“ CTRL-C”以終止終端中當前正在運行的程序。如果使用的是IDLE Python IDE，則必須按“ CTRL-D”退出正在運行的程序。如有疑問，請在開始編程之前進行Google搜索！\n\n在Windows上：鍵入“ CTRL-ALT-DEL”並打開任務管理器以終止程序。\n\n在Mac上：右鍵單擊該任務，然後終止永久運行的程序。\n\n如果發現自己陷入無限循環，則程序將永遠不會結束。 \n Break statements \n A \xa0 break \xa0 statement stops the execution of a loop before the original condition is met. While the use of a \xa0 break \xa0 statement will often start an argument about good coding practices, sometimes it is useful. \n For example: \n \n    while   True :  \n     usr_command   =   input ( "Enter your command: " ) \n     if   usr_command   ==   "quit" : \n       break \n     else :  \n       print ( "You typed "   +   usr_command ) \n \n In this case, the \xa0 break \xa0 statement is used to break off the “infinite while loop” that we have constructed with the \xa0 while True \xa0 statement. \n 中斷聲明\nbreak語句在滿足原始條件之前停止執行循環。儘管使用break語句通常會引發有關良好編碼實踐的爭論，但有時它很有用。\n\n例如：\n\n  而True：\n    usr_command = input（“輸入您的命令：”）\n    如果usr_command ==“ quit”：\n      打破\n    其他：\n      print（“您輸入了” + usr_command）\n在這種情況下，break語句用於中斷我們使用while True語句構建的“ while循環無限”。 \n \n \n \xa0 \n \xa0 \n \n \n \xa0 \n', 'tags': '', 'url': 'Exercise 8.html'}]};